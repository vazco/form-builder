"use strict";(self.webpackChunkforminer=self.webpackChunkforminer||[]).push([[981],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>u});var o=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=o.createContext({}),p=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return o.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},m=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),m=p(n),u=a,f=m["".concat(l,".").concat(u)]||m[u]||d[u]||r;return n?o.createElement(f,i(i({ref:t},c),{},{components:n})):o.createElement(f,i({ref:t},c))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var p=2;p<r;p++)i[p]=n[p];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}m.displayName="MDXCreateElement"},901:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>s,default:()=>m,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var o=n(7462),a=(n(7294),n(3905)),r=n(1201);const i={description:"Learn how to use your own components"},s="Handling custom components",l={unversionedId:"custom-components",id:"version-1.0.0/custom-components",title:"Handling custom components",description:"Learn how to use your own components",source:"@site/versioned_docs/version-1.0.0/custom-components.mdx",sourceDirName:".",slug:"/custom-components",permalink:"/docs/1.0.0/custom-components",draft:!1,tags:[],version:"1.0.0",frontMatter:{description:"Learn how to use your own components"},sidebar:"docs",previous:{title:"Display If",permalink:"/docs/1.0.0/display-if"},next:{title:"Handling lists",permalink:"/docs/1.0.0/handling-lists"}},p={},c=[{value:"Creating a custom field",id:"creating-a-custom-field",level:2},{value:"Passing a custom field definition to the <code>Forminer</code> and <code>Form</code>s",id:"passing-a-custom-field-definition-to-the-forminer-and-forms",level:2},{value:"Using a custom field",id:"using-a-custom-field",level:2},{value:"Example #2 - Map component",id:"example-2---map-component",level:2}],d={toc:c};function m(e){let{components:t,...i}=e;return(0,a.kt)("wrapper",(0,o.Z)({},d,i,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"handling-custom-components"},"Handling custom components"),(0,a.kt)("p",null,"By default, Forminer provides a set of essential components for handling form fields, such as inputs, dropdowns, checkboxes, etc."),(0,a.kt)("p",null,"These are the built-in components provided in any of the official uniforms themes. The complete list is available ",(0,a.kt)("a",{parentName:"p",href:"https://uniforms.tools/docs/api-fields"},"here"),"."),(0,a.kt)("p",null,"Even the basic set of components is a powerful tool for creating complex forms, but we understand that sometimes it is not enough. What if you need a dropdown that needs to fetch options from the API? What if your form requires an address and you want to handle it by selecting a point on the map?"),(0,a.kt)("p",null,"The answer to these questions is custom fields."),(0,a.kt)("p",null,"To start using custom fields you need to:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Create a custom field.")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Pass the custom field definition to your ",(0,a.kt)("inlineCode",{parentName:"p"},"Forminer")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"Form"),"s."))),(0,a.kt)("h2",{id:"creating-a-custom-field"},"Creating a custom field"),(0,a.kt)("p",null,"You can easily expand the basic set of form fields by creating your own, freely customizable, custom fields. The only requirement is that they need to be uniforms-compatible. Such fields can be created using the two helpers provided by uniforms: ",(0,a.kt)("a",{parentName:"p",href:"https://uniforms.tools/docs/api-helpers/#connectfield"},"connectField")," and ",(0,a.kt)("a",{parentName:"p",href:"https://uniforms.tools/docs/api-helpers/#usefield"},"useField"),"."),(0,a.kt)("p",null,"Both provide various props related to form management and allow hook your component to the form. The difference between the helpers is that the former is a component wrapper, whereas the latter is its hook version."),(0,a.kt)("p",null,"Take a look at this example implementation of the custom dropdown that loads options from a remote source, in this case, films from a Star Wars API."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"import React, { useEffect, useState } from 'react';\nimport { HTMLFieldProps, useField } from 'uniforms';\n\ntype StarWarsMovieFieldProps = HTMLFieldProps<string, HTMLSelectElement, {}>;\n\nexport function StarWarsMovieField(props: StarWarsMovieFieldProps) {\n  const [{ label, onChange, placeholder, value }] = useField(props.name, props);\n  const [films, setFilms] = useState([]);\n\n  useEffect(() => {\n    const fetchData = async () => {\n      const res = await fetch('https://swapi.dev/api/films');\n      const json = await res.json();\n\n      setFilms(json.results);\n    };\n\n    fetchData();\n  }, []);\n\n  return (\n    <label>\n      {label}\n      <div>\n        <select value={value} onChange={event => onChange(event.target.value)}>\n          <option value=\"\">{placeholder}</option>\n          {films.map(({ title }) => (\n            <option key={title} value={title}>\n              {title}\n            </option>\n          ))}\n        </select>\n      </div>\n    </label>\n  );\n}\n")),(0,a.kt)("h2",{id:"passing-a-custom-field-definition-to-the-forminer-and-forms"},"Passing a custom field definition to the ",(0,a.kt)("inlineCode",{parentName:"h2"},"Forminer")," and ",(0,a.kt)("inlineCode",{parentName:"h2"},"Form"),"s"),(0,a.kt)("p",null,"Once your custom fields are ready, you need to pass this information on to ",(0,a.kt)("inlineCode",{parentName:"p"},"Forminer")," and your ",(0,a.kt)("inlineCode",{parentName:"p"},"Form"),"s. Both accept a ",(0,a.kt)("inlineCode",{parentName:"p"},"components")," prop, which is a map of component definitions. A component definition is a React component itself and other options needed to render it correctly. The default configuration is described in the ",(0,a.kt)("inlineCode",{parentName:"p"},"createDefaultComponents")," function. To be able to use a custom field, we add it to the existing component map:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"import * as theme from 'uniforms-material';\nimport { FieldType, createDefaultComponents } from '../Forminer';\n\nconst components = createDefaultComponents(theme);\n\ncomponents.StarWarsMovieField = {\n  component: StarWarsMovieField,\n  dataTypes: [FieldType.String],\n};\n")),(0,a.kt)("p",null,"Notice the ",(0,a.kt)("inlineCode",{parentName:"p"},"dataTypes")," property above. It represents the data types that the component is capable of handling. In this case, it means that the StarWarsMovieField can handle string values. The ",(0,a.kt)("inlineCode",{parentName:"p"},"dataTypes")," property also allows you to group the components capable of handling the field, by the field's type. In other words, if you set ",(0,a.kt)("inlineCode",{parentName:"p"},"dataTypes")," to string, your component will appear in the list of selectable components that support this type in the Advanced section in the UI. If you provide multiple types in the ",(0,a.kt)("inlineCode",{parentName:"p"},"dataTypes")," (e.g. string and number), then in both cases it will be possible to select this component to handle the field. If you leave the array empty, you won't be able to select the component to handle your field from the UI."),(0,a.kt)("p",null,"It is worth mentioning that in the same way, you can also override standard fields, such as TextField."),(0,a.kt)("h2",{id:"using-a-custom-field"},"Using a custom field"),(0,a.kt)("p",null,"With a custom field defined as above, you can go to your Forminer instance and create a new text field. Inside of Edit field pane scroll down to the Advanced section and expand it to see the Component dropdown. Select your custom component and you're ready to go!"),(0,a.kt)("p",null,(0,a.kt)("img",{src:n(5195).Z,width:"1831",height:"900"})),(0,a.kt)("h2",{id:"example-2---map-component"},"Example #2 - Map component"),(0,a.kt)("p",null,"Another example of a custom field could be a map field. Let's say we need our form not only to display the map but also to allow users to pick the location and capture the coordinates. To do so, we can create a dedicated ",(0,a.kt)("inlineCode",{parentName:"p"},"MapField")," component."),(0,a.kt)("p",null,"In the example below, we use the ",(0,a.kt)("inlineCode",{parentName:"p"},"GoogleMapReact")," component from the ",(0,a.kt)("inlineCode",{parentName:"p"},"google-map-react")," package to render a map and the ",(0,a.kt)("inlineCode",{parentName:"p"},"useField")," hook from the ",(0,a.kt)("inlineCode",{parentName:"p"},"uniforms")," package to let it manage the state. Apart from the map, we also display selected coordinates. Notice that we stringify and parse the object value, that's because Forminer handles only primitives."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"import GoogleMapReact from 'google-map-react';\nimport React from 'react';\nimport { HTMLFieldProps, useField } from 'uniforms';\n\ntype MapFieldProps = HTMLFieldProps<string, HTMLSelectElement>;\n\nconst mapDefaults = {\n  center: { lat: 51.11243862359008, lng: 17.02195684736274 },\n  zoom: 12,\n};\n\nconst safeParse = (str: string) => {\n  try {\n    return JSON.parse(str);\n  } catch (error) {\n    return null;\n  }\n};\n\nexport function MapField(props: MapFieldProps) {\n  const [{ label, onChange, value }] = useField(props.name, props);\n  const coords = value ? safeParse(value) : null;\n\n  return (\n    <div>\n      <label>{label}</label>\n      <div style={{ display: 'flex', alignItems: 'center' }}>\n        <div style={{ height: '200px', width: '200px' }}>\n          <GoogleMapReact\n            defaultCenter={mapDefaults.center}\n            defaultZoom={mapDefaults.zoom}\n            onClick={({ lat, lng }) => onChange(JSON.stringify({ lat, lng }))}\n          />\n        </div>\n        <div>\n          Coordinates:\n          <pre>{JSON.stringify(coords, null, 2)}</pre>\n        </div>\n      </div>\n    </div>\n  );\n}\n")),(0,a.kt)("p",null,"Check the video below to see how to use the map component in the user interface:"),(0,a.kt)("video",{controls:!0},(0,a.kt)("source",{src:r.Z})))}m.isMDXComponent=!0},1201:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/medias/10158082-79187d9350d71bbe413b78eb682883cd.mp4"},5195:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/1015827-96be84d04a9d46e7bada4b47f01fb49e.gif"}}]);